todo

get serve working...
build isn't building resources/middleware/...
how to load resources, middleware, config and env on the server
use latest - if u put the * or latest for a dep version - run this command and it will update ur apps file w/ the latest version.

ssh into remote server. plugins for heroku? digitalocean?
neo
remove shell in build
middleware, decorators, static, ..., should prob hav subfolders for each app - but not cuz what if u wanted /static/aa and other folders in root
list resources via staTUS and see their routes.
postdeploy - leave a hook so someone can write a docker integration.

write your tests...last?
- generate tests feature. generates tests for resources, ...,. if test does not yet exist.
- list empty tests - you can keep calling generate tests as you continue to develope, eventually your will forget about some. this helps you get back to them.

---

actions

serve
- @todo
- /endpoint to return brahma.config.js, env, status, ...?, (ssh only)

build
- the async implementation is a hack. needs to make sure all files are written before resolving main promise.
  - *making the bulk of file copying async is the main time saver. u dont really save any time making writeFileSync async.

deploy
- maybe there is separate `deploy` and `update` functionality. deploy deploys server boilerplate that u dont update. update is how u update that boilerplate.
- ideally you just run deploy, you see the manifest (whhats going to happen), you agree, and then shit happens.
  - deploy everything or select items?
    - big con w/ deploying items is you can fuck up. e.g. if u deploy a version of the config that is out of date w/ live code.
    - but sometimes u have edited your resources locally, but that shit aint ready for prod and all u wanna do is update your config e.g. change the name of something.
    - could mitigate this if ur resources requested config as its own prop, so we know what config items our prod code needs.
- ci server? see "breaking from convention - ci server"
- for selecting items to deploy: do one of those yeoman style option list things where you select what u wanna deploy (config, env,)

watch
- @todo

testing
- @todo for resources/middleware/decorators/services and other shit? see if i can implement some of my new testing style
- i want to use mocha and chai. i could integrate this so that these tools can be replaced by the user. will prob just use as defaults but in future versions.

scafold
- like integrations, scafolding tools can be plugins. brahma-plugin-scafold
- i want to scafold - resources, ...
- should the tool be used to remove shit as well? remove resources? maybe this will be contrib plugin shit. a remove resource plugin should be able to do validation and make sure the removal wont break shit.

status
- @todo status makes sure you dont have conflicting ports in env.

---

cron
- this is an integration. make sure people can roll their own shit.

ratelimter
- this is an integration. make sure people can roll their own shit.

logger
- @todo how to integrate logdna.

integrations
- @todo
- so we have the "realtime" addon, but we could have others, so u would do "namespace/realtime" (phase II)

dependency management
- builds (OK)
- updates (@todo) - update live app, update running dev server (would be nice if we didnt need to do a server restart)

versioning
- i have an idea, i want to keep all apps w/ the same version. idk why. gotta flush this out.

env
- env var validation. make sure no one is updating to invalid types (object).

package.json


lifecycle states
- startup
- run
- shutdown

local and remote ssl
- how we gonna do this? a way to generate local ssl certs via command line command?

brahma advantages
- to be featured on readme
- you should be able to test remote configuations locally. e.g. test your dev build locally.


zmq
xreq/xres intelligent req/res. it think it knows where to route a reply.
listens and resonds to file io
i think u can use tcp for remote communcation and ipc for local communication.
doesnt seem to be a request/response pattern for the node module.
to do ack or replys, in the message field include a replyTo address,
and we can use either zmq or http to send a reply.

---

breaking from convention
- no dev dependencies - intented to make remote builds faster. we are not doing remote builds.
- one of the things we do w/ microservices is create github repos for each service and
sometimes set up hooks to deploy to webservers. lets find a way to not do this w/o tradeoffs...setting up
these private github repos is a bit of work,
- ci server - the server has a tests endpoint that runs our tests in a forked process, and communicates the results. why use another server - its just worse?

make sure...
- the apps should be able to start themselves given an brahma.app.js file and other configs.
dont compile too much. the idea is for redeployment we want to just upload the configs and resources.
- keep integrations modular. abstract out modules like mongorules and make the their own github repos e.g. brahma-mongorules?, brahma-...
- static assets w/ ID caching. make sure this is a technique people will be able to implement.
- should the app server be its own module? build it and see what it would take
- try to connect to servers using ssh and ur ssh key.

---

app

communication
- property on $ctx (proptype property)
- $ctx.handler
- $ctx.call('ygl.apartments.status.change', 'method') // if in resources obj call directly, else use rabbit rpc. if method is empty, calls 'handler'
- $ctx.get('ygl.apartments.status.change.config.field') // gets a field value.
- we should make sure decorators dont fuck w/ these methods so maybe we can attach them last?
set ctx to null inside objs?

resource validator
- makes sure you don't have a get property or a call prop or anything that we are using elseware

Resources have the following possible entry points:
- restful HTTP interface
- response to zmq task
- cron
* since we are wrapping the "handler" and triggering other functions, they should be able to declare the triggers. e.g. you may only want to trigger an action after handler was called from cron and not when it's accessed via http.

---

realtime
- handshake
  - client connects
  - server asks for JWT
  - server uses JWT to verify (via mamaba communication syntax)
  - server asks client for subscriptions
  - client sends subscriptions
  - server associates subscriptions list w/ socket client ID.
  - server listens for all events
    - for each event, get each users subs w/ filters, check to see if each user
    gets updated, and update
  - maybe we can integrate a restful interface to add montioring/control

---

brahma status
- brahma status (runs all brahma statuses)
- brahma status resources (validate resources objects)
- brahma status resource RESOURCE_NAME (tells u what other resources are dependencies)
- brahma status service SERVICE_NAME (tells u what resources are dependent)
- brahma status decorator
- brahma status middleware
- brahma status config
- brahma status dependencies APP_NAME lists all dependencies for a given app
- brahma status deploy (makes sure you have git repos defined for each server)
- makes sure all resources have a location entry in their brahma.config.js
- brahma stats ports  - make sure we are using unique ports.
- have a status to log dependencies for a remote server. log pack.json

---

// const resources = new ResourceCollection();
// resources.forEach
// resources.get()
// resources.get('resource.name')
// resources.add()
// resources.update()
// resources.remove()

--

/update
/update/dependencies
/update/resources

/update/config
/update/dbs/[dbName]/[add/remove/update/[custom]]
/update/decorators/[decoratorName]/[add/remove/update]
/update/docs?
/update/integrations?
/update/middleware/[name]/[add/remove/update]
/update/services
/update/utils
/update/brahmaConfig

/update/startup
/update/shutdown

---

long todos

- auto updating `brahma` cli module (1.0?)

I want to be able to list a dependency in a resource w/o needing to isntall it.
installation should happen automatically.
- 3 sources: local, github npm.
- push endpoint to remote.
  - reads dependencies
  - installs dependencies to node_modules
  - refetches dependencies by default
  - idea - might not need to use node_modules at all if u can do this locally to each endopoint
  - there shoudl be a naming collision check w/ dependencies. make sure we are not injecting another ygl object or something.
- i want to be able to use koa1.x and koa2.x in the same project.
