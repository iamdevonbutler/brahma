pre/post deploy hooks - how would we implement that?
do env.
should we have both $ctx and ctx?
needs a default request library. axios?
needs default decorors - lru

mongonrules database plugins need a way to integrate w/ generate and add createSchema files. fractal architecute?

where to put db schema.
load - being used in brahma configs too. require wouldnt clear cache.
requiring shit - how to require each resouce type.
plugin interfaces
bin? - what is the root command.
private - getallproperties map so other users can make their own ./private, folder/file structure, private assets for servers
./docs
app.js config, nginx option - configure load balancer and asset cache.
mongorules config
templating
api route prefix w/ version.
bin commands? what if a server wants bin commands.
how do u write a resource that loads and sends a static asset like a jpg.
hooks - how to manage a bunch of hooks for a bunch of apps.
custom helpers (./config/helpers.js)
custom db commands
upload more than one ssh key to server

http://blog.bitfinex.com/tutorial/bitfinex-loves-microservices-grenache/
https://www.youtube.com/watch?v=kR06NoSzAXY - this looks good. talks about setting up lets encrypt.
https://www.youtube.com/watch?v=BJZZnhGtR4A&t=322s
https://www.npmjs.com/package/vultr
https://jream.com/blog/post/time-saving-digital-ocean-vultr-startup-script
https://www.youtube.com/watch?v=FJrs0Ar9asY
https://www.nginx.com/blog/mitigating-ddos-attacks-with-nginx-and-nginx-plus/

---

needed functionality
- want a way to prefix all routes w/ api version or whatever.
- need to know how route matches are handled when there are matching multiple endpoints.
- debug integration? (tj's npm module)
- sitemap?
- a way to steam logs of remote servers like heroku allows.
- generate local ssl certs via command line command? - maybe its a `generate` integration.

---

commands

* commands register w/ vorpal by calling a `register` method, passed into their main file.

`db`
- custom database scripts.
- database backups - scheduling them and
- @todo

`helpers`
- @todo latestDependencies - updates pack.j w/ latest versions of packages.
- @todo looseEnds - see helpers/commands/looseEnds.
- plugin ecosystem, people can integrate help tasks.

`serve`
- @todo
- /endpoint to return app.js, env, status, ...?, (ssh only)

`build`
- the async implementation is a hack. needs to make sure all files are written before resolving main promise.
  - *making the bulk of file copying async is the main time saver. u dont really save any time making writeFileSync async.

`deploy`
- cycle server feature - command to refresh server like heroku does automatically.
- gotta be able to add custom nginx configs.
- upstart
- there is separate `deploy` and `update` functionality. deploy deploys server boilerplate that u dont update. update is how u update that boilerplate.
- ideally you just run deploy, you see the manifest (whhats going to happen), you agree, and then shit happens.
  - deploy everything or select items?
    - big con w/ deploying items is you can fuck up. e.g. if u deploy a version of the config that is out of date w/ live code.
    - but sometimes u have edited your resources locally, but that shit aint ready for prod and all u wanna do is update your config e.g. change the name of something.
    - could mitigate this if ur resources requested config as its own prop, so we know what config items our prod code needs.
- ci server? see "breaking from convention - ci server"
- for selecting items to deploy: do one of those yeoman style option list things where you select what u wanna deploy (config, env,)
- if deploying a single app to multiple boxes, deploy 2 1 box first, make sure shit works, then deploy the rest, or clone the boxes.
- neo servers are deployed, they register global cli commands, which we are gonna hit w/ ssh. make sure we check the path to be sure the bin exists OR run a status command and if it doesnt work say 'hey check ur path'.
- if dep/plugin versions are not fixed, we fix, install updated deps, run tests, then ask if the user wants to deploy. make it a rule, dont deploy non fixed versions.
- services
  - mongo free tier - https://www.mongodb.com/cloud/atlas/lp/general
  - redis free tier - https://redislabs.com/pricing/redis-cloud/
  - image cdn

`watch`
- @todo
- uses fork to fork new processes and change servers.

`testing`
- in ./tests, u should be able to write a test, that is used by multiple apps. in app config, pull in tests, do some wildcard path shit idk.
- @todo for resources/middleware/decorators/services and other shit? see if i can implement some of my new testing style
- i want to use mocha and chai. i could integrate this so that these tools can be replaced by the user. will prob just use as defaults but in future versions.
- write your tests...last?
  - generate tests feature. generates tests for resources, ...,. if test does not yet exist.
  - list empty tests - you can keep calling generate tests as you continue to develope, eventually your will forget about some. this helps you get back to them.
  - remove tests for shit that doesnt exist (y/N prompt)
- want ot be able to run all tests, one test, or match wildcard...so api.* all api tests
- WILL WANT A WAY TO RUN TESTS ON SERVER - should be called automatically on update.
- --watch. test on save tdd feature - when ur writing a util or something, tell it what the name of the file is, and on save, it will run your test. `test utils.thenify --watch`
- how to load fixtures
- tests: {unit, system}
- property name is "test" not "tests" - throw special error.
- how to emlutate before each? and before? and other scripts?

`new`
- git clone repos (brahma-boilerplate)
- should have a command or flag to build site w/ config folders vs config files and
folders vs files for other shit.

`generate`
- resource
- plugin
- react component - integration
- ...
- have a flag --all to generate an object w/ all properties. --basic --custom
- people will want to generate resources w/ certain decorators predefined.

`status`
- make sure no one is using require or import statements.
- if you are using any of the http properties make sure the location has http enabled.
- `brahma status resources`
  - validate resources - calls validate functions defined by integrations and your local tests.
  - use static analysis plugin to validate and prevent the use of `this`.
- `brahma status resource RESOURCE_NAME`
  - resource has a location property. its value is a registered app. (if not, log all errors so people can fix all at once)
- `brahma status routes`
  - list routes by each resource - resourceName|route
- `brahma status routes ROUTE`
  - returns matching the resource.
  - 2 flags. one flag to match '/users/:id' and another to match '/user/122'. --exact -e
  - @todo how to handle routes that have multiple matches. i think koa-router (which we should
  mention we are using in the docs) hits all matched enodpoints but i could be wrong. keep
  in mind, the order in which we load routes is unknown to the user.
- `brahma status require`
  - brahma status require resource.name|service.name|middleware.name|decorator.name|...
  - tells u what is requiring the resource, and what the resource is requiring.
- `brahma status services|decorator|middleware|utils`
  - lists all services|decorator|middleware|utils
  - runs tests. services are npm modules which should be tested on their own.
  but what about custom services?
  - maybe list what's requiring them too (redundant but OK)
- `brahma status config`
  - runs basic validation for each config. our validation and integration validation for their config (thinking about seprating configs from integrations, so integrations dont fuck w/ the apps.js file)
  - makes sure you dont have conflicting ports when env === settings.localEnvironment.
- `brahma status dependencies`
  - makes sure dependencies were installed correctly ('npm i' worked).
  - lists dependencies and their versions (useful for debugging remote servers)

---
assets
- asset config file. i like the idea of creating a map for assets, the obj can have props for static caching, like a cache id and shit.? a method that passes in a asset name and some other data and u return the path.

aliases?
- user can alias DI. e.g. call 'environment' 'env' if they want????

dependencies
- you dont manage a centralized dependency graph?

private
- keep local certs there.
- @todo helper command to generate local certs.
- in .gitignore
- default dirPath is ./private but on remote servers can be anywhere.
- @todo need a way to let users who clone the repo know what to put in here
- @todo what if u want env to be private?
- maybe have some deploy integration, post deploy, make it easy for users to create their private dir.
solves the problem of how to get private shit on remote servers.

hooks (see notes why it's hooks vs callbacks)
- app.start
- app.stop
- app.update
- custom?
- ./callbacks or in callbacks.js export callbacks
- each cb has a pre and post method. can pass just a function to run

plugins
- make sure plugins of type "app" have access to all other plugin hooks (i think)
  - they should have the ability to add commands for shit like database queries?
- i wanna see if i can do some fractal recursive architecture shit for app plugins.

resources
- @see neo

callbacks
- callbacks are just functions that get called by somethign.
the best way to create a callback is to create ./endpoints/callbacks

endpoints
- endpoints vs other resources. resources have access to other resources via DI, endpoints are special - they have can be accessed by other endpoints using the $call method.
- organization:
  - by app (./api, ./worker, ./...)
  - by type (./commands - bin commands, ./callbacks - called by one or more apps, ./router - output one ore more apps)
  - by collection (database driven design, ./employees, ./stores, ./tags)
  - @see readme.

caching
- for endpoints:
  - cache decorators. 'lcache' 'mcache' 'redis'

Dependency Pathing
- abs paths...
- 'a1': './services/a1'
- '{a1}': './services'
- '{callOnce}': './utils'
- 'callOnce': './utils/callOnce'
- u write it like this everywhere. in resources. in utils.

Route pathing
- endpoint "route" property to override default.

settings
- nodeVersion - not implemented, check to make sure node is of the proper version.
- require using 'const' - if we have a `require` field in our utils and resources
and we are importing a npm module, we are going to make it var by default, because
people will want to mutate data and if we dont there will be errors.

contrib
- apps, decorators, middleware, endpoints, utils (make everything contribable)
- `brahma-${type}-${name}`
- types = [decorator, decorators, middleware, middlewares ...]
- namspace contrib. e.g. iamdevonbutler/decoratorName
- @todo document naming conventions

documentation
- we want the ability for plugins to create their own site for documentation
or github repo at least.
- plugins can implement a docs property on our resource, but docs should be more than just
an explination of resources. how do u contribute a general comment on the architecture.
- integrate w/ gitbook

DI & status (or could there be an `info` command)
- i want the ability to identify a resource, and for each property, know what is injected.

resource versions (endpoints, services, utils, decorators, middleware, plugins)
- should have a helper function identify what resource has multiple versions
and what code is requiring each version.

validation
- kinda a edge case, but u should be able to write custom validators for your configs.
e.g. environment. might want to do type checking.
- put custom validators in lib

auth
- this is a very common problem. find a way to modularize and contribute.

config files
- package.js (u can add decription and other fields for some reason, dep versions?)
- helpers.js (adds helper commands to `helpers`)


static analyisis
- can check and make sure people are passing the proper number of params to functions
either when using $ctx, or when using pre() and post({}, args)
- { main(null, param) } // make sure u dont pass null. will error normally but the message sucks.

command queue/buffer
- when ur downloading dependencies, users may want to take other actions, need to queue them.

apps.js
- updating ur apps file, e.g. you enable cors, we need a way to download koa-cors when in watch mode

Renaming shit
- renaming a server (how does it affect the rest of your code - does the updating suck?)
  - would be awesome if we could identify the dependencies either though static analysis or otherwise
  - think what else do u rename and how to help w/ that.

front end apps
- I really dont want to cater to front end apps since i plan on building my own webgl webapp framework
- headless browser testing

---

apps to build
- *like plugins, you can plug in another brahma app. it will go to build, and takes config so it can be sorta dynamic.
- website (make it functionally eq to rails).
- realtime
- worker
- cron
- smtp
- router

---

youtube videos
- general
- documentation rundown
- architectural discusssion
- demo w/ corey
- beginner screencast - very detailed?
- how to build a simple website - inspired by rails
- how to build some complex shit
- * make a bunch of little videos so people can easily find out how to do shit. can also make a big video too and cut clips out from it.
- * videos do that zoom in shit, like they zoom in on close shit. not essential.

---

realtime app
- handshake
  - client connects
  - server asks for JWT
  - server uses JWT to verify (via mamaba communication syntax)
  - server asks client for subscriptions
  - client sends subscriptions
  - server associates subscriptions list w/ socket client ID.
  - server listens for all events
    - for each event, get each users subs w/ filters, check to see if each user
    gets updated, and update
  - maybe we can integrate a restful interface to add montioring/control
* this is a reminder to let me know that our apps need a way to communicate that is secure.

---

make sure...
- the apps should be able to start themselves given an app.js file and other configs.
dont compile too much. the idea is for redeployment we want to just upload the configs and resources.
- keep integrations modular. abstract out modules like mongorules and make the their own github repos e.g. brahma-mongorules?, brahma-...
- static assets w/ ID caching. make sure this is a technique people will be able to implement.
- should the app server be its own module? build it and see what it would take
- try to connect to servers using ssh and ur ssh key.
- auto install dependencies.
- use koa1.x and koa2.x in the same project but on seprate apps (if a dependent is requring w/o sepcifiying a version obs return the greater version).
- for stuff u gotta write a lot make sure then names are brief. i would use 'docs' over 'documentation' as the name for an object property.
- if i end up using regex, wrap it in a utility function. it's just so gross.
- fast. local updates are fast. remote updates are fast.
- u can upload images from a website and throw it in S3
- it has a good way to reuse common functionality across projects like forgot password functionality
- i can write have an app create a rails site and use custom routing, custom index page, custom about page.

functionality looking for use cases:
- pre() post() ???
- different file names and object name.
- custom brahma command.

---

Brahma dev todos

make a logs and errors file full of functions for consistent formatting.

---

Brahma website

- built w/ brahma
- https://codepen.io/john052/pen/KzIfb?page=4

---

Maya
- you want your routes local to your maya project, but that data is also needed by
your API server -> maya can locally integrate w/ brahma, give it data, and brahma makes
http route endpoints.

long todos
- if ur writing a rails type app, and u go to a URL, and theres errors, send down one of those pretty error templates
- how would u write a front-end app like react or something? (not super important - maybe there should be a way to build a framework for shit like this that integrates w/ brahma!)
- unit tests (objAssignDeep)
- update repo keywords
- \n -> EOL
- "sponsors" and "backers" section on Readme (see koa)
- handling video and audio streams.
- remove brahma-documenation repo? (if were not gonna use it)
- find a way to keep your code DRY across multiple brahma projects.

Upgrading w/ breaking changes.
- when we create a 1.x if there are breaking changes do this:
create a new GH repos called brahma-1 and bramha-0.
bramha is the same as bramha-0.
after a while make bramha eql to bramha-1
