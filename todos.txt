API
- load
  - load.private()
  - load.resource()
  - load.config()
  - load.merge(path, {data})
  - clear require cache param?
- readStream
- read
  - read.static();
  - read.private('', true);
- env
  - env.get()
  - env.set()
- variables
  - variables.get()

Convention
- all reads via read are async?

---


- build all plugin interfaces



env
- default { overwrite: true, refresh: true }
  - constants are opt in. JS paradigm.
  - performance is opt in, predictability takes precedent here.

env = {
  router: {
    local: {
      'key.a': 'value',
      'key.b': 'value',
    },
    remote0: {},
  },
  worker: {
    local: {},
    remote0: {},
  },
};

{
  data,
  raw, // original object.

  forEach() {},
  every() {},
  filter() {},
  some() {},
  find() {},

  clone() {},
  assign() {},

  select(...args) {}, // .select() w/ no params returns this.data (whole obj)
  get() {},
  set() {}, // set w/ property specific validation.
}

env = createInterface(env, {
  depth: 2,
  wrapValues: true,
  filterData(obj) {
    return obj.connections;
  },
  defaults(key, value, parents = null) {
    return {
     name: key,
      ...(value || {}),
    };
  },
  validate(key, value, parents) {}, // validates each item.
  transform(key, value, parents = null) {},
  select(...args) {
    return args ? args.reduce((obj, arg) => obj[arg], this.data) : this.data;
  }
});

env.select('router', 'local') // return local.
env.select('router', 'remote0') // return remote0.

env.get('key.a');
env.set('key.a', 'value');
env.select('router', 'remote0').get('key.a'); // can use this to get types such as endpoint, service.
env.forEach(item => {

});
env
  .type('local')
  .filter((obj, key) => key[key.length - 1] === 'a')
  .forEach();

---

schema
(nestedKey1, nestedKey2, ...) => {
  // appName === nestedKey1;
  'http.port': {
    default: '',
    validate() {},
    transform() {},
  },
}

---

@todo data structure for all configs and resources.
@todo when u get a env, (the value is an obj, but we want to filter and just return the value property, have it be an interface feature)
@todo if a value is updated, make sure we can have update() callbacks, if someone updates the refresh value we want to react to that.
- all values for resources and config have update callbacks, and when updated, it runs validation first, returns errors if shitty,

schema
- need to validate keys - make sure our env.js keys point to valid apps
- validate values w/ obj above
- sometimes apply the schema to all properties and othertimes apply different schemas

// env.js - this is something that the env module exports to brahma.
createSchema({
  depth: 0,
  keys: {
    deferred: {
      each(key, value, {apps}) {
      return {
        error: Object.keys(apps).indexOf(key) > -1 ? null : 'invalid appname', // validate w/ error
        value: undefined, // transform
      };
    },
    },
  },
  values: {},
}, {
  depth: 1,
  keys: {
    all(keys) {
      return {
        error: keys.indexOf('local') > -1 ? null : 'must include local'
      }
    }
  }
}, {
  depth: 2,
  keys: {
    needs: ['port'],
  },
  values: {
   schema: createSchema({
     depth: 0,
     fields: {
       value: {
         required: {
           true,
           error() {}
         },
         transform() {

         }
       },
       refresh: {

       }
     }
   }),
  },
  // and port
});


resources = {
  endpoints: {
    key: {},
  },
  services: {
    key: {},
  },
  decorators: {},
};

resources = createInterface(resources, {
  depth: 1,
  schema,
})

resources.forEach(resource => {});
resources.select('endpoints', 'router').forEach(resource => {});

---

required: false,
notNull: false,
default: undefined,
type: null,
minLength: [null, null],
maxLength: [null, null],
validate: [null, null],
trim: false,
lowercase: false,
uppercase: false,
sanitize: false,
denyXSS: false,
filterNulls: false,
transform: [null, null],

---

config
- injectables (loaded in this order)
  - settings.js (nothing)
  - variables.js: settings (no env, its static)
  - env.js: settings, variables,
  - apps.js: env, variables, settings
  - remote.js: env, variables, settings, apps (apps for the hell of it)
  - dbs.js: env, variables, settings, apps, remote
  - plugins.js: env, variables, settings, apps, remote, dbs
- @todo document injectables for each config.

---

theres a generic object interface and a resource interface.

resource adaptors npm library? 'resource-adaptor'?
if i build a good resource adaport thing, w/ built in testing, it will be easy to
abstract out the attach itterators functionality and have it follow the adaptor format
it should do testing w/o needing to locally install mocha and shit.
itterator functionality is resource-collection resource-interface

const {
  applyInterface,
  createCollection,
  initResources,
} = require('brahma-resource');

var resource = load('resource');
resource = interface(resource);
var array = collection(resource, resource);

applyResourceInterface
// validation
// defaults
// wraps resource
// api to interact w/ resource


resources = resources.map(resource => applyResourceInterface(resource));
resources = createResourceCollection(resources);
- or -
resources = initResources(resources);
resources.forEach(resource => {
  resource.name = 'a'; // updates name.
})
resources.data = [];


---

echo brahma version

complex data
- should have an api to itterate and do anythine else u wanna do
- resources have a manifest that we create beforehand, for times when properties accept
multiple values we dont wanna have to run typechecking a million tinmes, so create a manifest
and have it accessible on the API

remote
- helper - get bandwidth - bandwidth analysis page

thinking we might have to force git.
git commits and tagging for deployments should probably be a best practive.
idk. still want streaming updates.

review nodes strengths and weakenssses on google.

abilities
- i like the idea of plugging shit it and getting abilities because of it.
so if u plugged in a cron thing, u have the ability to rotate logs.

docs
- ssh docs setup is wrong and incomplete
- resources architecture

@tobuild
- core plugins

test SSH!

vultr
- ubuntu 16 is LTS (document)

where do prod apps write to?
- ./tmp - called tmp because once that remote server gets destroyed when u downscaled ur env, the data is gone.
- need to write logs, cache, and other information on running apps.
  - distibuted apps should avoid writing to server for continunity.
- would perfer to use s3 exculsivly for file writes
  - add s3 config to project setup if its necessary.
  - document why we dont like to handle static assets w/ node.
  - if not, need a local dir to write to.

build
- may only need to build a single app and deploy everywhere. maybe there is no build.
- if we dont do build have a way, via deploy, to add files to apps.

brahma-proxy-nginx proxy: true?
- hooks into generate and writes a nginx.conf in merge as well as other shit.

want a way to checkout a different versions of the site, u should be able to upload a new version but not have it take effect until u manually check it out. so u can put up commits for site maintaince

ssh into node process? how to run `app status`.

how would a website load CSS and JS (@todo for brahma-website). get fast css reloads working.

generate
- if u run generate, there is some yeoman questionair type shit. have forsm that are fixed, and forms that repeat (useful for mongorules)

./docs
- general project documentation. can be integrated w/ by brahma-app-documenation

nginx
- app.js option - auto enabled when secure === true
- documentation on how to configure as a static asset cache.

mongorules config
- @todo
- if we have config in a dbs dir - dbs isnt exactly a standard resource,
so it wont exist as load.dbs(), so we need a generic way to load stuff
(see if the config can take config format or resources format)

`remote` API (remote plugins must have these methods)
- addSSHKeys
- removeSSHKeys
- listSSHKeys must return an Oject w/ required properties such as ID so we can remove key.

---

Server config.

https://support.rackspace.com/how-to/checking-listening-ports-with-netstat/

ufw
- https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-with-ufw-on-ubuntu-14-04
- https://www.youtube.com/watch?v=fEwuvSbMImk

---

file storage
- i think s3 has private file storage.

---

needed functionality
- want a way to prefix all routes w/ api version or whatever.
- need to know how route matches are handled when there are matching multiple endpoints.
- debug integration? (tj's npm module)
- sitemap?
- reading deploy output. u could be deploying 10 apps at a time, buffer the logs, and only show one app at a time.

---

apps.js
- each property can have custom validation. e.g. ipv6 validates address.
- build process needs to DI data into our configs. by default we build for local, but `remote update` --env=remote0 will set activeEnv to remote0
- modules: http is a module, proxy is a module. modules define their data e.g. validate, defaults, and transform config. it does other shit too, idk rifht now tho.

---

cli (endpoint method)
- @todo ssh into remote node app.
- ssh calls ~/brahma/appName/bin/cli.js
- cli.js uses phone.local (ipc unix socket) to call resource endpoint lisitener (listen via decorator implementation when `cli` property is configured)
- how would this test locally?

---

plugins

- brahma-remote-digitalocean
  - https://github.com/matt-major/do-wrapper

- brahma-app-logs
 - like logdna. has database config.

- brahma-proxy-nginx
  - installs on same system if node === and newNode === true

- brahma-app-cron
  - https://github.com/kelektiv/node-cron
    - write custom wrapper over cronttab? i want to but how do u get it to work locally.
  - has a plugin for server refreshes - brahma-app-cron-plugin-refresh. the plugin basically adds endpoints (somehow) and probably a little config too. recursive architecture.

- brahma-database-mongodb
  - needs to hook into `generate` and register createSchema. fractal architecute?

- brahma-template-jsx

- brahma-library-essentials
  - request -> axios, adds as an injectable (@todo document adding an injectable)

- plugin status (or info?). run a status command, and view information about the plugin. e.g. if it registers helpers, what are these helpers.
- app plugins can have plugins.
- plugin that registers w/ the deploy pre hook to make sure u did a git tag before updating. can abort deploy.
  - not doing because tagging is going to be in core. but leave to make sure this would still be possible.
- plugins hook into status to talk about their system dependencies. e.g. brahma-database-mongodb wants mongod running - need to check (database-mongond integrates w/ serve which integreate w/ status to add a check for mongod).
- plugins document via API how theyre goning to modify your project. so they can say that their going to ad a dir in root or add a config file.
- docs - "integration" or "config"?
- should there be a generic way to create a custom plugin - one that doesnt have a type? hopefully we covered everything.
- brahma-command-git
- make sure plugins of type "app" have access to all other plugin hooks (i think)
  - they should have the ability to add commands for shit like database queries?
- i wanna see if i can do some fractal recursive architecture shit for app plugins.
- plugin updates? should we install a new version, run tests, install next plugin, tests, itteate? maybe new plugin version have update instructions. that could be a feature of resources, some update integration functionality.
- [brahma-build-humans](@todo) - hooks into build and adds a humans.txt w/ data from config. maybe make more generic, a project asset router - can add a humans from merge.
- for each recomended plugin, do an example in ./docs/plugins/examples/XXX and reference the example on the recomended plugins page.
- build plugin: brahma-build-packj
- app plugin: brahma-app-documentation hooks into status and registers a command to make sure a docs dir exists

---

http
- optionally enables ipv6. checks server to make sure its enabled.

vorpal
- @todo gonna roll my own cli.
- https://github.com/SBoudrias/Inquirer.js
- prompt

static
- readonly by convention? write to 'tmp'.
  - how to handle profile pic uploads, and updates to that upload?
    - s3. easy.
    - u couldn't write it to /tmp or anything local.
- @todo s3 integration

config
- modules need a way to respond to cahnges in config.
- config might need its own injectables. what if u wanna use path?
- should config be a resource.
   - wont need config.js
   - will be more consistent
   - resources should be flexible, they are currently designed around functions, but should
   consider the importance of exporting other types of data.

assets
- asset config file. i like the idea of creating a map for assets, the obj can have props for static caching, like a cache id and shit.? a method that passes in a asset name and some other data and u return the path.

aliases?
- can't aliash injectables. want projects to be consistent.
- can't alias dirnames in settings config.

dependencies
- you dont manage a centralized dependency graph?

private
- in .gitignore
- explain how to integrate private data w/ env.
- @todo need a way to let users who clone the repo know what to put in here
- maybe have some deploy integration, post deploy, make it easy for users to create their private dir.
solves the problem of how to get private shit on remote servers.

hooks (see notes why it's hooks vs callbacks)
- app.start
- app.stop
- app.update
- custom?
- ./callbacks or in callbacks.js export callbacks
- each cb has a pre and post method. can pass just a function to run

endpoints
- endpoints vs other resources. resources have access to other resources via DI, endpoints are special - they have can be accessed by other endpoints using the $call method.
- organization:
  - by app (./api, ./worker, ./...)
  - by type (./commands - bin commands, ./callbacks - called by one or more apps, ./router - output one ore more apps)
  - by collection (database driven design, ./employees, ./stores, ./tags)
  - @see readme.

caching
- for endpoints:
  - cache decorators. 'lcache' 'mcache' 'redis'

Dependency Pathing
- abs paths...
- 'a1': './services/a1'
- '{a1}': './services'
- '{callOnce}': './utils'
- 'callOnce': './utils/callOnce'
- u write it like this everywhere. in resources. in utils.

Route pathing
- endpoint "route" property to override default.

settings
- nodeVersion - not implemented, check to make sure node is of the proper version.
- require using 'const' - if we have a `require` field in our utils and resources
and we are importing a npm module, we are going to make it var by default, because
people will want to mutate data and if we dont there will be errors.

contrib
- apps, decorators, middleware, endpoints, utils (make everything contribable)
- `brahma-${type}-${name}`
- types = [decorator, decorators, middleware, middlewares ...]
- namspace contrib. e.g. iamdevonbutler/decoratorName
- @todo document naming conventions

documentation
- cmd+shift+p search, bookmarking (localstorage), config accepts multiple sites, deploys to S3 (plugin)
- we want the ability for plugins to create their own site for documentation
or github repo at least.
- plugins can implement a docs property on our resource, but docs should be more than just
an explination of resources. how do u contribute a general comment on the architecture.
- integrate w/ gitbook

DI & status (or could there be an `info` command)
- i want the ability to identify a resource, and for each property, know what is injected.

resource versions (endpoints, services, utils, decorators, middleware, plugins)
- should have a helper function identify what resource has multiple versions
and what code is requiring each version.

validation
- kinda a edge case, but u should be able to write custom validators for your configs.
e.g. environment. might want to do type checking.
- put custom validators in lib

auth
- this is a very common problem. find a way to modularize and contribute.
- confirm email functionality and email
- forgot password functionality and email

static analyisis
- can check and make sure people are passing the proper number of params to functions
either when using $ctx, or when using pre() and post({}, args)
- { main(null, param) } // make sure u dont pass null. will error normally but the message sucks.

command queue/buffer
- when ur downloading dependencies, users may want to take other actions, need to queue them.

apps.js
- updating ur apps file, e.g. you enable cors, we need a way to download koa-cors when in watch mode

naming
- stage and production. wish i had better names.

Renaming shit
- renaming a server (how does it affect the rest of your code - does the updating suck?)
  - would be awesome if we could identify the dependencies either though static analysis or otherwise
  - think what else do u rename and how to help w/ that.

---

apps to build
- brahma-website (make it functionally eq to rails).
  - templating integration
  - pulls docs dir from brahma github repo and builds static site. simple cli command to update site.
  - how to do links for shit in our markdown files?
- brahma-example-simple
  - loads plugins via plugins.js
- brahma-example-advanced
  - worker
  - router
  - cron
  - smtp
  - realtime
  - ...requires all plugins and config (plugins are local in ./plugins)

---

youtube videos
- general
- documentation rundown
- architectural discusssion
- demo w/ corey
- beginner screencast - very detailed?
- how to build a simple website - inspired by rails
- how to build some complex shit
- small videos
  - how we manage private data
  - ... @todo
- * make a bunch of little videos so people can easily find out how to do shit. can also make a big video too and cut clips out from it.
- * videos do that zoom in shit, like they zoom in on close shit. not essential.

---

make sure...
- update the technologies list in the Readme.
- varnish cache (w. nginx) web pages.
- we can load and send (stream too) a static asset
- api route prefix w/ version. - give a general way for them to modify koa - via start hook.
- the apps should be able to start themselves given an app.js file and other configs.
dont compile too much. the idea is for redeployment we want to just upload the configs and resources.
- keep integrations modular. abstract out modules like mongorules and make the their own github repos e.g. brahma-mongorules?, brahma-...
- static assets w/ ID caching. make sure this is a technique people will be able to implement.
- should the app server be its own module? build it and see what it would take
- try to connect to servers using ssh and ur ssh key.
- auto install dependencies.
- use koa1.x and koa2.x in the same project but on seprate apps (if a dependent is requring w/o sepcifiying a version obs return the greater version).
- for stuff u gotta write a lot make sure then names are brief. i would use 'docs' over 'documentation' as the name for an object property.
- if i end up using regex, wrap it in a utility function. it's just so gross.
- fast. local updates are fast. remote updates are fast.
- u can upload images from a website and throw it in S3
- it has a good way to reuse common functionality across projects like forgot password functionality
- i can write have an app create a rails site and use custom routing, custom index page, custom about page.

---

functionality looking for use cases:
- pre() post() ???
- different file names and object name.
- custom brahma command.
- passing "apps" into remote.js and other config injectables

---

Brahma dev todos

make a logs and errors file full of functions for consistent formatting.

---

Brahma website

- built w/ brahma
- https://codepen.io/john052/pen/KzIfb?page=4

---

long todos
- use the word paradigm more in docs. paradigm shifting framework.
- if ur writing a rails type app, and u go to a URL, and theres errors, send down one of those pretty error templates
- how would u write a front-end app like react or something? (not super important - maybe there should be a way to build a framework for shit like this that integrates w/ brahma!)
- unit tests (objAssignDeep)
- update repo keywords
- \n -> EOL
- "sponsors" and "backers" section on Readme (see koa)
- handling video and audio streams.
- remove brahma-documenation repo? (if were not gonna use it)
- find a way to keep your code DRY across multiple brahma projects.
- vultr API has methods like /server/start that restart a box - can we disable this?

---

Upgrading w/ breaking changes.
- when we create a 1.x if there are breaking changes do this:
create a new GH repos called brahma-1 and bramha-0.
bramha is the same as bramha-0.
after a while make bramha eql to bramha-1

---

Maya
- you want your routes local to your maya project, but that data is also needed by
your API server -> maya can locally integrate w/ brahma, and using the data in the maya project,
it creates a custom app plugin for Mayas API.
-

---

jsmoves
- Infinity
- mention does not support symbols
