commands
- each command registers w/ vorpal in its own repo by calling the register method.

.data
- being a version store is problematic when multiple people are deploying from repos.
- try another method. maybe ping, get last version, then deploy.

do rails tutorials

gotta think about how to do integration tests and e2e tests.
tests are props on obj for middleware, decorators, resource ,...

bin commands? what if a server wants bin commands.

brahma-app-smtp
brahma-app-realtime
brahma-app-cron
- like plugins, you can plug in another brahma app. it will go to build, and takes config so it can be sorta dynamic.
- @todo architecture

callbacks
- app.start
- app.stop
- app.update
- custom?
- ./callbacks or in callbacks.js export callbacks
- each cb has a pre and post method. can pass just a function to run

no presets - plugins wont be too verbose

namespace contrib plugins, apps, decorators, middleware, resource

resource, decorator, service, middleware, plugin, app, and all plugin mounts {
  name: 'overridesFilename',
  ...
} use this interface

i feel like much of the contrib shit should be straight JS objects.

test ssh
https://github.com/mscdex/ssh2#connection-hopping

maybe make the load config functions more generic.
should be a way to load a file, set defaults (deep), validate? and return an obj.

config
- provide an object OR a function.

maybe we use a pull strategy for linking dependencies.
rather than organizing static assets, decorators middleware static ...,
in a defined way, sacrificing peolples ability to scale at the cost of disorganization,
we let people include shit in those top level dirs anyway they want, and we distribute them
based on the way they are included in resources and the main and shutdown files?
- provide conventions for how to organize folders tho

middleware, decorators, static, ..., should prob hav subfolders for each app - but not cuz what if u wanted /static/aa and other folders in root

presets and plugins (ok name, could be better)
- presets are collections of plugins
- plugins integrate into various aspects of brahma (multiple mounting points)
- thinking of a {
  cron: require('brahma-plugin-cron')
}

where would u put all ur mongorules config.
where would u put ssh credentials, api keys, passwords for shit
- in config, maybe make it convention for plugins to put config in config w/ a prefix maybe? dont love it, name conflicts

Services
 - mwb a1 file (how would this work)
 - i like the idea of giving people freedom in creating their folder structure. big apps gotta do weird shit sometimes.

People are going to do auth for sites, we want a modular way of using that same implemention across projects.

When planning the client architecture, make sure chnages are fast.
so if you change the name of your api server, make sure u dont need to update a million other things.
add this to some architectural goals list in the readme.


since we are doing the live update thing...
we are required to update dependencies (files of code) and static assets (more files)
so we are going to be writing to disk
so the architecture needs to support this...


how to update node_modules while live
- could update pack.j -> run npm i -> clear require cache;
- big problem. npm is super unreliable and debugging its logs on remote systems sucks.
- so let's ship dependencies from our local to prod...
  - post deploy file checksum - do a recursive grep of remote files and compare concatenated file strings and also add up the file size.
  - post deploy run tests on the remote machine
- ./neo
  - ./dependencies
    - ./@todo
      - ./node_modules
      - ./static
  - ./lib
  - ./bin
- will need to set NODE_PATH='yourdir'/node_modules
- will still need to clear the require cache

we are forgetting database shit.

versioning
- what if we do semver, starting at 0.1.0 and each  update auto incremented the version
and by passing flags --updateMajor --updateMinor you could do the obvious
- where is the version stored

there are just resources
at the core of this you begin and end in resources
resources do depend on some other things
but everything eventually integrates w/ resources
resources directly integrate w/ systems:
  - services (libraries, email, sms, 3rd party apis, utility code, ...)
  - decorators
  - middleware
  - databases
  - static assets
  - caches. both local and remote.
  - other resources. both local and remote.
  - dynamic (env) config
  - static config
  - logging
  - cron
  - realtime
a decorator is a function
and this function can have dependencies
decorators need to ship w/ their resources to remote computers
so does middleware
middleware works very similar to decorators
so do services but they are more often collections of files
decorators and middleware are usually single files
but they can be collections of files all w/ depenendcies
all this needs to ship to remote systems.
require() is used to include dependencies
import is used too. often interchangeably.
the api is similar but the differences are greater when you get more low-level im sure
import isnt really standard yet (2017)
services are often contrib on npm and github
an example of a service is `axios`
services are used by everything...resources, decorators, middleware, other services
where as decorators are used only by resources
middleware is used only by resources

how to transport and load decorators/middleware/plugins/services.
- managing dependencies is your first issue.
  - how do u handle a contrib decorator requiring some npm module.
  - we need to ship the required code

architecture
- renaming a server (how does it affect the rest of your code - does the updating suck?)
  - would be awesome if we could identify the dependencies either though static analysis or otherwise
  - think what else do u rename and how to help w/ that.
updating ur apps file, e.g. you enable cors, we need a way to download koa-cors when in watch mode

to test jsmoves
- hijack all requires and pass eberything though jsmoves. see if the app still works.

status
- should regex all resources (and perhaps other stuff too) and make sure no one is using require or import statements
in their code.

middleware
- for http use w/ koa
- resource middleware is a decorator

there should be a way of organizing various types of middleware. the same goes for
decorators, services, and ...

private
- keep local certs there.
- @todo helper command to generate local certs.
- in .gitignore
- default dirPath is ./private but on remote servers can be anywhere.
- @todo need a way to let users who clone the repo know what to put in here

decorators
- provide good documentation here. use autolog as an example to demonstrate the gotchyas.
- mention that their super powerful and they are the easiest way to fuck shit up.

how do u write a resource that loads and sends a static asset like a jpg.

think of how to manage the ecosystem of contribtued shit.
- how to keep track of it all.
- naming conventions (document in readme and elseware)
- brahma-plugin-NAME
- brahma-

see if we can make a generic neo interface for message services
might have to be baked in

@todo how u gonna do app init() and shutdown() funcs.

in ./config
- make sure people can replace an apps.js file w/ an ./config/apps/index.js

how do u dynamically require static assets and serve them inside resources.
/static {
  route:
  http() {}
}
// `route` and `http` are made available by the koa plugin.

---

actions

helpers
- @todo latestDependencies - updates pack.j w/ latest versions of packages.
- @todo looseEnds - see helpers/commands/looseEnds.
- plugin ecosystem, people can integrate help tasks.

serve
- @todo
- /endpoint to return brahma.config.js, env, status, ...?, (ssh only)

build
- the async implementation is a hack. needs to make sure all files are written before resolving main promise.
  - *making the bulk of file copying async is the main time saver. u dont really save any time making writeFileSync async.

deploy
- there is separate `deploy` and `update` functionality. deploy deploys server boilerplate that u dont update. update is how u update that boilerplate.
- ideally you just run deploy, you see the manifest (whhats going to happen), you agree, and then shit happens.
  - deploy everything or select items?
    - big con w/ deploying items is you can fuck up. e.g. if u deploy a version of the config that is out of date w/ live code.
    - but sometimes u have edited your resources locally, but that shit aint ready for prod and all u wanna do is update your config e.g. change the name of something.
    - could mitigate this if ur resources requested config as its own prop, so we know what config items our prod code needs.
- ci server? see "breaking from convention - ci server"
- for selecting items to deploy: do one of those yeoman style option list things where you select what u wanna deploy (config, env,)
- if deploying a single app to multiple boxes, deploy 2 1 box first, make sure shit works, then deploy the rest, or clone the boxes.

watch
- @todo
- uses fork to fork new processes and change servers.

testing
- @todo for resources/middleware/decorators/services and other shit? see if i can implement some of my new testing style
- i want to use mocha and chai. i could integrate this so that these tools can be replaced by the user. will prob just use as defaults but in future versions.
- write your tests...last?
  - generate tests feature. generates tests for resources, ...,. if test does not yet exist.
  - list empty tests - you can keep calling generate tests as you continue to develope, eventually your will forget about some. this helps you get back to them.
  - remove tests for shit that doesnt exist (y/N prompt)
- want ot be able to run all tests, one test, or match wildcard...so api.* all api tests
- WILL WANT A WAY TO RUN TESTS ON SERVER - should be called automatically on update.

new
- git clone repos (brahma-boilerplate)

generate
- resource
- plugin
- react component - integration
- ...

status
- `brahma status resources`
  - validate resources - calls validate functions defined by integrations and your local tests.
  - use static analysis plugin to validate and prevent the use of `this`.
- `brahma status resource RESOURCE_NAME`
  - resource has a location property. its value is a registered app. (if not, log all errors so people can fix all at once)
- `brahma status routes`
  - list routes by each resource - resourceName|route
- `brahma status routes ROUTE`
  - returns matching the resource.
  - 2 flags. one flag to match '/users/:id' and another to match '/user/122'. --exact -e
  - @todo how to handle routes that have multiple matches. i think koa-router (which we should
  mention we are using in the docs) hits all matched enodpoints but i could be wrong. keep
  in mind, the order in which we load routes is unknown to the user.
- `brahma status require`
  - brahma status require resource.name|service.name|middleware.name|decorator.name|...
  - tells u what is requiring the resource, and what the resource is requiring.
- `brahma status services|decorator|middleware|utils`
  - lists all services|decorator|middleware|utils
  - runs tests. services are npm modules which should be tested on their own.
  but what about custom services?
  - maybe list what's requiring them too (redundant but OK)
- `brahma status config`
  - runs basic validation for each config. our validation and integration validation for their config (thinking about seprating configs from integrations, so integrations dont fuck w/ the apps.js file)
  - makes sure you dont have conflicting ports when env === settings.localEnvironment.
- `brahma status dependencies`
  - makes sure dependencies were installed correctly ('npm i' worked).
  - lists dependencies and their versions (useful for debugging remote servers)

---

needed functionality
- want a way to prefix all routes w/ api version or whatever.
- need to know how route matches are handled when there are matching multiple endpoints.
- debug integration? (tj's npm module)
- sitemap?
- a way to steam logs of remote servers like heroku allows.
- generate local ssl certs via command line command? - maybe its a `generate` integration.

aliases
- user can alias DI. e.g. call 'environment' 'env' if they want.

utils
- @todo

documentation
- we want the ability for plugins to create their own site for documentation
or github repo at least.
- plugins can implement a docs property on our resource, but docs should be more than just
an explination of resources. how do u contribute a general comment on the architecture.
- integrate w/ gitbook

versioning
- i have an idea, i want to keep all apps w/ the same version. idk why. gotta flush this out.

validation
- kinda a edge case, but u should be able to write custom validators for your configs.
e.g. environment. might want to do type checking.
- put custom validators in lib

package.json
- package.js

process.env
- conventionally does strings only. not anymore. w/ js moves we can make it much more dynamic.

lifecycle states
- startup
- run
- shutdown

---

app

templating
- ejs? handlebars? pick my fav, do it, then allow the others to be built using plugins.

zmq
xreq/xres intelligent req/res. it think it knows where to route a reply.
listens and resonds to file io
i think u can use tcp for remote communcation and ipc for local communication.
doesnt seem to be a request/response pattern for the node module.
to do ack or replys, in the message field include a replyTo address,
and we can use either zmq or http to send a reply.

---

apps to build
- website (make it functionally eq to rails).
- realtime
- worker
- cron
- smtp (w/ templating)
- api

youtube videos
- general
- architectural discusssion
- demo w/ corey
- how to build a simple website - inspired by rails
- how to build some complex shit

---

realtime app
- handshake
  - client connects
  - server asks for JWT
  - server uses JWT to verify (via mamaba communication syntax)
  - server asks client for subscriptions
  - client sends subscriptions
  - server associates subscriptions list w/ socket client ID.
  - server listens for all events
    - for each event, get each users subs w/ filters, check to see if each user
    gets updated, and update
  - maybe we can integrate a restful interface to add montioring/control
* this is a reminder to let me know that our apps need a way to communicate that is secure.

---

make sure...
- the apps should be able to start themselves given an brahma.app.js file and other configs.
dont compile too much. the idea is for redeployment we want to just upload the configs and resources.
- keep integrations modular. abstract out modules like mongorules and make the their own github repos e.g. brahma-mongorules?, brahma-...
- static assets w/ ID caching. make sure this is a technique people will be able to implement.
- should the app server be its own module? build it and see what it would take
- try to connect to servers using ssh and ur ssh key.
- auto install dependencies.
- use koa1.x and koa2.x in the same project.

---

long todos
- how would u write a front-end app like react or something? (not super important - maybe there should be a way to build a framework for shit like this that integrates w/ brahma!)
- youtube video
- tests
- read zmq codebase
- update repo keywords
- \n -> EOL
- use neo-core fixed version - not 'latest'
