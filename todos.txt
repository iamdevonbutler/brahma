test ssh

middleware, decorators, static, ..., should prob hav subfolders for each app - but not cuz what if u wanted /static/aa and other folders in root

https://github.com/mscdex/ssh2#connection-hopping

presets and plugins (ok name, could be better)
- presets are collections of plugins
- plugins integrate into various aspects of brahma (multiple mounting points)
- thinking of a {
  cron: require('brahma-plugin-cron')
}

server.js
- logdna and bunyan.

The idea is that we dont have a ./apps dir, and that we keep everything generic
in the way we code. our services, decorators, middleware, it's all generic.
Services
 - mwb a1 file (how would this work)

People are going to do auth for sites, we want a modular way of using that same implemention across projects.

When planning the client architecture, make sure chnages are fast.
so if you change the name of your api server, make sure u dont need to update a million other things.
add this to some architectural goals list in the readme.


---

actions

helpers
- @todo latestDependencies
- plugin ecosystem, people can integrate help tasks.

serve
- @todo
- /endpoint to return brahma.config.js, env, status, ...?, (ssh only)

build
- the async implementation is a hack. needs to make sure all files are written before resolving main promise.
  - *making the bulk of file copying async is the main time saver. u dont really save any time making writeFileSync async.

deploy
- maybe there is separate `deploy` and `update` functionality. deploy deploys server boilerplate that u dont update. update is how u update that boilerplate.
- ideally you just run deploy, you see the manifest (whhats going to happen), you agree, and then shit happens.
  - deploy everything or select items?
    - big con w/ deploying items is you can fuck up. e.g. if u deploy a version of the config that is out of date w/ live code.
    - but sometimes u have edited your resources locally, but that shit aint ready for prod and all u wanna do is update your config e.g. change the name of something.
    - could mitigate this if ur resources requested config as its own prop, so we know what config items our prod code needs.
- ci server? see "breaking from convention - ci server"
- for selecting items to deploy: do one of those yeoman style option list things where you select what u wanna deploy (config, env,)

watch
- @todo

testing
- @todo for resources/middleware/decorators/services and other shit? see if i can implement some of my new testing style
- i want to use mocha and chai. i could integrate this so that these tools can be replaced by the user. will prob just use as defaults but in future versions.
- write your tests...last?
  - generate tests feature. generates tests for resources, ...,. if test does not yet exist.
  - list empty tests - you can keep calling generate tests as you continue to develope, eventually your will forget about some. this helps you get back to them.
  - remove tests for shit that doesnt exist (y/N prompt)
- want ot be able to run all tests, one test, or match wildcard...so api.* all api tests
- WILL WANT A WAY TO RUN TESTS ON SERVER - should be called automatically on update.

scafold
- like integrations, scafolding tools can be plugins. brahma-plugin-scafold
- i want to scafold - resources, ...
- should the tool be used to remove shit as well? remove resources? maybe this will be contrib plugin shit. a remove resource plugin should be able to do validation and make sure the removal wont break shit.

status
- @todo status makes sure you dont have conflicting ports in env.
- no news is good news. returns nothing if shits good. document behavior in readme.

---

plugins
- just be sure someone can write a docker deploy plugin
- mounting points:
  - `helpers`
  - `new`
  - `deploy`
  - logger
  - ratelimiter
  - database
  - cron
  - docs
  - mail
  - static asset cdn
  - versioning?
  - ...

dependency management
- builds (OK)
- updates (@todo) - update live app, update running dev server (would be nice if we didnt need to do a server restart)

versioning
- i have an idea, i want to keep all apps w/ the same version. idk why. gotta flush this out.

env
- env var validation. make sure no one is updating to invalid types (object).

package.json

process.env
- conventionally does strings only. not anymore. w/ js moves we can make it much more dynamic.

lifecycle states
- startup
- run
- shutdown

local and remote ssl
- how we gonna do this? a way to generate local ssl certs via command line command?

brahma advantages
- to be featured on readme
- you should be able to test remote configuations locally. e.g. test your dev build locally.


zmq
xreq/xres intelligent req/res. it think it knows where to route a reply.
listens and resonds to file io
i think u can use tcp for remote communcation and ipc for local communication.
doesnt seem to be a request/response pattern for the node module.
to do ack or replys, in the message field include a replyTo address,
and we can use either zmq or http to send a reply.

neo {
  main() {}
  http() {}
  cron() {}
  custom() {}
  docs: []
}
idea - neo can be an architecture and a GH repo that uses its architecture. not everything needs to be its own framework.

SSH commands
- `neo status` - logs ?


---

breaking from convention
- no dev dependencies - intented to make remote builds faster. we are not doing remote builds.
- one of the things we do w/ microservices is create github repos for each service and
sometimes set up hooks to deploy to webservers. lets find a way to not do this w/o tradeoffs...setting up
these private github repos is a bit of work,
- ci server - the server has a tests endpoint that runs our tests in a forked process, and communicates the results. why use another server - its just worse?
- process.env uses jsmoves and can be any jsmoves type.
- main.js > index.js

make sure...
- the apps should be able to start themselves given an brahma.app.js file and other configs.
dont compile too much. the idea is for redeployment we want to just upload the configs and resources.
- keep integrations modular. abstract out modules like mongorules and make the their own github repos e.g. brahma-mongorules?, brahma-...
- static assets w/ ID caching. make sure this is a technique people will be able to implement.
- should the app server be its own module? build it and see what it would take
- try to connect to servers using ssh and ur ssh key.

---

app

communication
- property on $ctx (proptype property)
- $ctx.handler
- $ctx.call('ygl.apartments.status.change', 'method') // if in resources obj call directly, else use rabbit rpc. if method is empty, calls 'handler'
- $ctx.get('ygl.apartments.status.change.config.field') // gets a field value.
- we should make sure decorators dont fuck w/ these methods so maybe we can attach them last?
set ctx to null inside objs?

resource validator
- makes sure you don't have a get property or a call prop or anything that we are using elseware

Resources have the following possible entry points:
- restful HTTP interface
- response to zmq task
- cron
* since we are wrapping the "handler" and triggering other functions, they should be able to declare the triggers. e.g. you may only want to trigger an action after handler was called from cron and not when it's accessed via http.

---

realtime
- handshake
  - client connects
  - server asks for JWT
  - server uses JWT to verify (via mamaba communication syntax)
  - server asks client for subscriptions
  - client sends subscriptions
  - server associates subscriptions list w/ socket client ID.
  - server listens for all events
    - for each event, get each users subs w/ filters, check to see if each user
    gets updated, and update
  - maybe we can integrate a restful interface to add montioring/control

---

brahma status
- brahma status (runs all brahma statuses)
- brahma status resources (validate resources objects)
- brahma status resource RESOURCE_NAME (tells u what other resources are dependencies)
- brahma status routes
- brahma status service SERVICE_NAME (tells u what resources are dependent)
- brahma status decorator
- brahma status middleware
- brahma status config
- brahma status dependencies APP_NAME lists all dependencies for a given app
- brahma status deploy (makes sure you have git repos defined for each server)
- makes sure all resources have a location entry in their brahma.config.js
- brahma stats ports  - make sure we are using unique ports.
- have a status to log dependencies for a remote server. log pack.json

---

// const resources = new ResourceCollection();
// resources.forEach
// resources.get()
// resources.get('resource.name')
// resources.add()
// resources.update()
// resources.remove()

--

/update
/update/dependencies
/update/resources

/update/config
/update/dbs/[dbName]/[add/remove/update/[custom]]
/update/decorators/[decoratorName]/[add/remove/update]
/update/docs?
/update/integrations?
/update/middleware/[name]/[add/remove/update]
/update/services
/update/utils
/update/brahmaConfig

/update/startup
/update/shutdown

---

long todos

- youtube video
- tests
  - utils
- read zmq codebase

I want to be able to list a dependency in a resource w/o needing to isntall it.
installation should happen automatically.
- 3 sources: local, github npm.
- push endpoint to remote.
  - reads dependencies
  - installs dependencies to node_modules
  - refetches dependencies by default
  - idea - might not need to use node_modules at all if u can do this locally to each endopoint
  - there shoudl be a naming collision check w/ dependencies. make sure we are not injecting another ygl object or something.
- i want to be able to use koa1.x and koa2.x in the same project.
